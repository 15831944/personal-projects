// LEDSignToolKit.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "LEDSignToolKit.h"
#include "LEDSignToolKitDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLEDSignToolKitApp

BEGIN_MESSAGE_MAP(CLEDSignToolKitApp, CWinApp)
	//{{AFX_MSG_MAP(CLEDSignToolKitApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLEDSignToolKitApp construction

CLEDSignToolKitApp::CLEDSignToolKitApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLEDSignToolKitApp object

CLEDSignToolKitApp theApp;

void __getCPUID(DWORD* result,DWORD param)
{
/************************************************/
// GET CPUID command OPCODE = 0xA20F			//
//----------------------------------------------//
// EAX = 0 --> Get Vendor = {EBX-EDX-ECX}		//
// EAX = 1 --> Get EBX,EDX = {Cache,ALU,CPU}	//
// EAX = 2 --> Get Cache Info					//
// EAX = 3 --> Serial no = {EAX,EBX,ECX,EDX}	//
// EAX = 80000000H ->80000004H {adv func CPU}	//
/************************************************/	
#ifndef  _DEBUG

	DWORD buffer[4];
__asm 
	{
		MOV EAX, param		

		CPUID			// 27 bytes = 1B		

		MOV dword ptr [buffer+ 0], EAX
		MOV dword ptr [buffer+ 4], EBX
		MOV dword ptr [buffer+ 8], ECX
		MOV dword ptr [buffer+12], EDX
	}

	memcpy(result,buffer,sizeof(DWORD)*4);

#endif
}

BOOL __getHDDSerial(LPDWORD pSerial)
{
	DWORD dwRes = 0;
	TCHAR buffer[MAX_PATH] = {0};
	return GetVolumeInformation(_T("C:\\"),buffer,sizeof(buffer),pSerial,&dwRes,&dwRes,buffer,sizeof(buffer));
}

union landi{
	unsigned short int i[2];
	unsigned int l;
};

struct DateStruct
{
	unsigned short int dd;
	unsigned short int mm;
	unsigned short int yyyy;
};

#define SWAP2(s) ((((s) >> 8) & 0xFF) | (((s) << 8) & 0xFF00))

#define SWAP4(l) ((((l) >> 24) & 0xFF) | ((((l) & 0xFF0000) >> 8) & 0xFF00) \
                         | (((l) & 0xFF00) << 8) | ((l) << 24))

unsigned short int ActiCodeCheck(
									const unsigned int uiBoxID, 
									const unsigned int uiUserCode, 
									unsigned int uiActivationCode,
									DateStruct* stDate ) /* out */
{
	unsigned int serial;		/* BoxID	: 01234567 */
	unsigned int zip;			/* UserCode : 01234567 */
	unsigned int code;			/* Activation code : 23723612 */
	unsigned int delta=3323;

	serial = uiBoxID;
	zip = uiUserCode;
	code  = uiActivationCode;

	//takes in the serial number.. zip code and the key which is the password generated by the encipher function..
	unsigned int sum=(delta*32), key1 = zip, key2 = serial;
	landi y;
	unsigned int n = 0;
	y.l= code;

   /* Swap 4 for Little and Big Endian compatiblity */
#ifdef WIN32
   y.l    = SWAP4 (y.l);
   y.i[0] = SWAP2 (y.i[0]);
   y.i[1] = SWAP2 (y.i[1]);
#endif

	while(n < 32){             // going backwards from 0 to 32..
		y.i[1] -= (y.i[0]>>3) + key2 ^ y.i[0] + sum ^ (y.i[0] << 5) + (key1>>(n%7));
		// subtract the vaules so it can get back to the original value after the cycles

		y.i[0] -= (y.i[1]>>5) + key1 ^ y.i[1] + sum ^ (y.i[1] << 3) + (key2>>(n%7));
		sum -= delta;
		//decrease the sum by delta..
		n++;
	}
	if(y.i[0] == (unsigned short int)serial) // if the high part matchs the serial number then it is a valid password...
	{		
		int dd,mm,yyyy;
		unsigned short int flag = y.i[1];	
		/* EndDate	: dddd-dmmm-myyy-yyyy*/

		yyyy = (unsigned short int)(flag&0x07F);
		mm = (unsigned short int )((flag>>7)&0x0F);
		dd = (unsigned short int)((flag>>11)&0x1F);

		yyyy = 2000 +yyyy;	// from 2000 to 2127
		stDate->dd = dd;
		stDate->mm = mm;
		stDate->yyyy = yyyy;

		return flag; //this is the options flags being returned use this value to set all the options flags...
	}
	else
	{
		memset(stDate,0,sizeof(stDate));
		return 0;	//returns 0 if this is not a valid password	
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLEDSignToolKitApp initialization

BOOL CLEDSignToolKitApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	SetRegistryKey(_T("AD Technology Center"));
		
	DWORD dwActivateCode = GetProfileInt("Setting",_T("SerialKey"),0);

	DWORD dwCPUID = 0;
	__getCPUID(&dwCPUID,3);
	DWORD dwSerialHDD = 0;
	__getHDDSerial(&dwSerialHDD);

	DateStruct stDate;

	if (ActiCodeCheck(dwCPUID, dwSerialHDD, dwActivateCode, &stDate) != 0)
	{
		CTime time = CTime::GetCurrentTime();
		if ( (time.GetYear() > stDate.yyyy) ||
			 ((time.GetYear() == stDate.yyyy) && (time.GetMonth() > stDate.mm))
			)
		{
			MessageBox(NULL,"Invalid Activation Code. Please contact your provider","Activation",MB_OK);
			return FALSE;
		}
	}
	else
	{
		MessageBox(NULL,"Invalid Activation Code. Please contact your provider","Activation",MB_OK);
		return FALSE;
	}

	CLEDSignToolKitDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
